[
  {
    "_id": "1",
    "name": "Array",
    "content": "<p>Arrays are fundamental data structures in Java used to store multiple values of the same type in a single variable. They offer a convenient way to manage collections of data. For example, if you need to store the ages of several people, instead of creating individual variables for each age, you can use an array to hold all ages in a single data structure.</p>\n<h3>Declaring Arrays</h3>\n<p>In Java, arrays are declared by specifying the type of elements and the square brackets <code>[]</code>. The type can be any data type, including primitive types (like <code>int</code>, <code>float</code>, etc.) and reference types (like <code>String</code>, <code>Object</code>, etc.).</p>\n<pre><code>Type[] arrayName;</code></pre>\n<p>Example:</p>\n<pre><code>String[] cars;</code></pre>\n<pre><code>int[] numbers;</code></pre>\n<h3>Initializing Arrays</h3>\n<p>Initialization is the process of assigning values to an array after declaring it. You can initialize arrays either at the time of declaration or separately after declaration.</p>\n<h4>Inline Initialization:</h4>\n<pre><code>String[] cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"};</code></pre>\n<pre><code>int[] myNum = {10, 20, 30, 40};</code></pre>\n<h4>Separate Initialization:</h4>\n<pre><code>String[] cars = new String[4];</code></pre>\n<pre><code>cars[0] = \"Volvo\";</code></pre>\n<pre><code>cars[1] = \"BMW\";</code></pre>\n<pre><code>cars[2] = \"Ford\";</code></pre>\n<pre><code>cars[3] = \"Mazda\";</code></pre>\n<h3>Accessing Array Elements</h3>\n<p>Array elements are accessed using their index, which starts at 0. The syntax to access an element is:</p>\n<pre><code>arrayName[index];</code></pre>\n<p>Example:</p>\n<pre><code>String[] cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"};</code></pre>\n<pre><code>System.out.println(cars[0]); // Outputs Volvo</code></pre>\n<h3>Modifying Array Elements</h3>\n<p>To change the value of an element in an array, you use the index and assign a new value to it.</p>\n<p>Example:</p>\n<pre><code>String[] cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"};</code></pre>\n<pre><code>cars[0] = \"Opel\";</code></pre>\n<pre><code>System.out.println(cars[0]); // Outputs Opel</code></pre>\n<h3>Array Length</h3>\n<p>The <code>length</code> property of an array provides the number of elements in the array. It is useful for looping through arrays and ensuring you do not exceed the bounds of the array.</p>\n<p>Example:</p>\n<pre><code>String[] cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"};</code></pre>\n<pre><code>System.out.println(cars.length); // Outputs 4</code></pre>\n<h3>Looping Through Arrays</h3>\n<h4>For Loop:</h4>\n<p>A standard <code>for</code> loop is commonly used to iterate through the elements of an array. It requires initializing a counter, checking a condition, and updating the counter.</p>\n<p>Example:</p>\n<pre><code>String[] cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"};</code></pre>\n<pre><code>for (int i = 0; i < cars.length; i++) {</code></pre>\n<pre><code>  System.out.println(cars[i]);</code></pre>\n<pre><code>}</code></pre>\n<h4>For-Each Loop:</h4>\n<p>The enhanced <code>for-each</code> loop is designed for iterating over arrays and collections without needing an index. It is more readable and concise.</p>\n<p>Syntax:</p>\n<pre><code>for (Type element : arrayName) {</code></pre>\n<pre><code>  // Use element</code></pre>\n<pre><code>}</code></pre>\n<p>Example:</p>\n<pre><code>String[] cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"};</code></pre>\n<pre><code>for (String car : cars) {</code></pre>\n<pre><code>  System.out.println(car);</code></pre>\n<pre><code>}</code></pre>\n<h3>Multidimensional Arrays</h3>\n<p>Java supports multidimensional arrays, which are essentially arrays of arrays. They are useful for representing more complex data structures like matrices or tables.</p>\n<p>Declaration:</p>\n<pre><code>int[][] matrix;</code></pre>\n<p>Initialization:</p>\n<pre><code>int[][] matrix = {</code></pre>\n<pre><code>  {1, 2, 3},</code></pre>\n<pre><code>  {4, 5, 6},</code></pre>\n<pre><code>  {7, 8, 9}</code></pre>\n<pre><code>};</code></pre>\n<p>Accessing Elements:</p>\n<pre><code>System.out.println(matrix[0][1]); // Outputs 2</code></pre>\n<h3>Real-Life Examples</h3>\n<h4>Calculating Average Age</h4>\n<p>Arrays are often used in real-world applications for statistical calculations, such as finding averages.</p>\n<p>Example:</p>\n<pre><code>int[] ages = {20, 22, 18, 35, 48, 26, 87, 70};</code></pre>\n<pre><code>float sum = 0;</code></pre>\n<pre><code>int length = ages.length;</code></pre>\n<pre><code>for (int age : ages) {</code></pre>\n<pre><code>  sum += age;</code></pre>\n<pre><code>}</code></pre>\n<pre><code>float average = sum / length;</code></pre>\n<pre><code>System.out.println(\"The average age is: \" + average);</code></pre>\n<h4>Finding the Lowest Age</h4>\n<p>Finding specific values in an array, such as the minimum or maximum value, is a common task.</p>\n<p>Example:</p>\n<pre><code>int[] ages = {20, 22, 18, 35, 48, 26, 87, 70};</code></pre>\n<pre><code>int lowestAge = ages[0];</code></pre>\n<pre><code>for (int age : ages) {</code></pre>\n<pre><code>  if (age < lowestAge) {</code></pre>\n<pre><code>    lowestAge = age;</code></pre>\n<pre><code>  }</code></pre>\n<pre><code>}</code></pre>\n<pre><code>System.out.println(\"The lowest age is: \" + lowestAge);</code></pre>\n<h3>Advanced Array Concepts</h3>\n<h4>Dynamic Arrays</h4>\n<p>In Java, <code>ArrayList</code> from the <code>java.util</code> package provides a dynamic array that can grow and shrink as needed. Unlike fixed-size arrays, <code>ArrayList</code> offers methods to add, remove, and access elements easily.</p>\n<p>Example:</p>\n<pre><code>import java.util.ArrayList;</code></pre>\n<pre><code>ArrayList<String> cars = new ArrayList<>();</code></pre>\n<pre><code>cars.add(\"Volvo\");</code></pre>\n<pre><code>cars.add(\"BMW\");</code></pre>\n<pre><code>cars.add(\"Ford\");</code></pre>\n<pre><code>cars.add(\"Mazda\");</code></pre>\n<pre><code>for (String car : cars) {</code></pre>\n<pre><code>  System.out.println(car);</code></pre>\n<pre><code>}</code></pre>\n<h4>Jagged Arrays</h4>\n<p>Jagged arrays (arrays of arrays where sub-arrays can have different lengths) are useful for scenarios where the number of elements varies between sub-arrays.</p>\n<p>Example:</p>\n<pre><code>int[][] jaggedArray = new int[3][];</code></pre>\n<pre><code>jaggedArray[0] = new int[2];</code></pre>\n<pre><code>jaggedArray[1] = new int[3];</code></pre>\n<pre><code>jaggedArray[2] = new int[1];</code></pre>\n<pre><code>jaggedArray[0][0] = 1;</code></pre>\n<pre><code>jaggedArray[0][1] = 2;</code></pre>\n<pre><code>jaggedArray[1][0] = 3;</code></pre>\n<pre><code>jaggedArray[1][1] = 4;</code></pre>\n<pre><code>jaggedArray[1][2] = 5;</code></pre>\n<pre><code>jaggedArray[2][0] = 6;</code></pre>\n<h3>Conclusion</h3>\n<p>Arrays are a powerful tool in Java programming, offering efficient ways to store and manipulate collections of data. Understanding how to declare, initialize, access, modify, and iterate through arrays is fundamental for effective Java programming. Advanced concepts like dynamic arrays and jagged arrays further expand the versatility of arrays in Java applications.</p>\n"
  },
  {
    "_id": "2",
    "name": "LinkedList",
    "content": "<p>Linked List is a linear data structure where elements are stored in nodes. Each node contains a reference (or link) to the next node in the sequence. This structure allows for efficient insertion and deletion of elements as it does not require shifting elements like in arrays.</p>\n<h3>Types of Linked Lists</h3>\n<ul>\n  <li><b>Single Linked List:</b> Each node has a single link to the next node.</li>\n  <li><b>Doubly Linked List:</b> Each node has links to both the next and previous nodes.</li>\n  <li><b>Circular Linked List:</b> The last node links back to the first node, forming a circle.</li>\n</ul>\n<h3>Operations on Linked List</h3>\n<ul>\n  <li><b>Insertion:</b> Adding a new node to the list.</li>\n  <li><b>Deletion:</b> Removing a node from the list.</li>\n  <li><b>Traversal:</b> Accessing each node in the list.</li>\n</ul>\n<h3>Implementation Example</h3>\n<pre><code>class Node {\n  int data;\n  Node next;\n\n  Node(int data) {\n    this.data = data;\n    this.next = null;\n  }\n}</code></pre>\n<pre><code>class LinkedList {\n  Node head;\n\n  void insert(int data) {\n    Node newNode = new Node(data);\n    if (head == null) {\n      head = newNode;\n    } else {\n      Node temp = head;\n      while (temp.next != null) {\n        temp = temp.next;\n      }\n      temp.next = newNode;\n    }\n  }\n\n  void printList() {\n    Node temp = head;\n    while (temp != null) {\n      System.out.print(temp.data + \" \");\n      temp = temp.next;\n    }\n    System.out.println();\n  }\n}</code></pre>\n<h3>Advantages of Linked List</h3>\n<ul>\n  <li>Dynamic size.</li>\n  <li>Efficient insertion and deletion operations.</li>\n</ul>\n<h3>Disadvantages of Linked List</h3>\n<ul>\n  <li>Memory overhead due to storing references.</li>\n  <li>Sequential access of elements, making it less efficient for random access.</li>\n</ul>\n<h3>Conclusion</h3>\n<p>Linked lists offer flexibility and efficiency in certain scenarios where dynamic data structures are needed. Understanding their structure and operations is crucial for leveraging their advantages in various programming tasks.</p>\n"
  },
  {
    "_id": "3",
    "name": "Tree",
    "content": "<p>A tree is a non-linear data structure that consists of nodes connected by edges. It is used to represent hierarchical relationships. The top node is called the root, and each node can have zero or more child nodes. Trees are widely used in computer science for various applications like representing hierarchical data, parsing expressions, and more.</p>\n<h3>Types of Trees</h3>\n<ul>\n  <li><b>Binary Tree:</b> Each node has at most two children (left and right).</li>\n  <li><b>Binary Search Tree (BST):</b> A binary tree where nodes are arranged in a way that for each node, the left child’s value is less than the node’s value, and the right child’s value is greater.</li>\n  <li><b>Balanced Tree:</b> A binary tree where the height difference between left and right subtrees is minimized.</li>\n  <li><b>Heap:</b> A special kind of binary tree used in heap sort and priority queues.</li>\n</ul>\n<h3>Operations on Trees</h3>\n<ul>\n  <li><b>Insertion:</b> Adding a new node to the tree.</li>\n  <li><b>Deletion:</b> Removing a node from the tree.</li>\n  <li><b>Traversal:</b> Visiting all nodes in a specific order (e.g., inorder, preorder, postorder).</li>\n</ul>\n<h3>Implementation Example</h3>\n<pre><code>class Node {\n  int data;\n  Node left, right;\n\n  Node(int data) {\n    this.data = data;\n    left = right = null;\n  }\n}</code></pre>\n<pre><code>class BinaryTree {\n  Node root;\n\n  void insert(int data) {\n    root = insertRec(root, data);\n  }\n\n  Node insertRec(Node root, int data) {\n    if (root == null) {\n      root = new Node(data);\n      return root;\n    }\n    if (data < root.data) {\n      root.left = insertRec(root.left, data);\n    } else if (data > root.data) {\n      root.right = insertRec(root.right, data);\n    }\n    return root;\n  }\n\n  void inorder() {\n    inorderRec(root);\n    System.out.println();\n  }\n\n  void inorderRec(Node root) {\n    if (root != null) {\n      inorderRec(root.left);\n      System.out.print(root.data + \" \");\n      inorderRec(root.right);\n    }\n  }\n}</code></pre>\n<h3>Advantages of Trees</h3>\n<ul>\n  <li>Hierarchical representation of data.</li>\n  <li>Efficient search, insertion, and deletion operations in binary search trees.</li>\n</ul>\n<h3>Disadvantages of Trees</h3>\n<ul>\n  <li>Complexity in implementation and balancing (for balanced trees).</li>\n  <li>Memory overhead due to additional pointers or references.</li>\n</ul>\n<h3>Conclusion</h3>\n<p>Trees are a versatile data structure used to model hierarchical data. Understanding different types of trees and their operations is fundamental for solving complex problems in computer science.</p>\n"
  }
]
